using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR.iOS;
using UnityEngine.UI;

public class PlaneGenerator : MonoBehaviour
{
	public GameObject planePrefab;
    private MyARAnchorManager unityARAnchorManager;

    public GameObject visPrefab;

    public Transform m_HitTransform;
    public float maxRayDistance = 30.0f;
    public LayerMask collisionLayer = 1 << 10;  //ARKitPlane layer


    public Text debugTextBox;
    private string debugInfo = "";

    private string planeID = "";

    private bool planeDetectionStopped = false;
    private bool gameCharacterPlaced = false;

    public GameObject gamePlaneParent;
    public GameObject gamePlane;
    public GameObject gamePlaneOrigin;
    private ARPlaneAnchor selectedPlaneAnchor;
    
    // Use this for initialization
    void Start () {
        unityARAnchorManager = new MyARAnchorManager();
		UnityARUtility.InitializePlanePrefab (planePrefab);
        
    }

    void Update()
    {
        if (planeDetectionStopped && !gameCharacterPlaced)
        {
            #if UNITY_EDITOR   //we will only use this script on the editor side, though there is nothing that would prevent it from working on device
                if (Input.GetMouseButtonDown(0))
                {
                    Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
                    RaycastHit hit;

                    //we'll try to hit one of the plane collider gameobjects that were generated by the plugin
                    //effectively similar to calling HitTest with ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent
                    if (Physics.Raycast(ray, out hit, maxRayDistance, collisionLayer))
                    {
                        //we're going to get the position from the contact point
                        m_HitTransform.position = hit.point;
                        Debug.Log(string.Format("x:{0:0.######} y:{1:0.######} z:{2:0.######}", m_HitTransform.position.x, m_HitTransform.position.y, m_HitTransform.position.z));

                        //and the rotation from the transform of the plane collider
                        m_HitTransform.rotation = hit.transform.rotation;
                    }
                }
            #else
                if (Input.touchCount > 0 && m_HitTransform != null)
                {
                    var touch = Input.GetTouch(0);
                    if (touch.phase == TouchPhase.Began || touch.phase == TouchPhase.Moved)
                    {
                        var screenPosition = Camera.main.ScreenToViewportPoint(touch.position);
                        ARPoint point = new ARPoint {
                            x = screenPosition.x,
                            y = screenPosition.y
                        };

                        // prioritize reults types
                        ARHitTestResultType[] resultTypes = {
                            //ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingGeometry,
                            ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent, 
                            // if you want to use infinite planes use this:
                            //ARHitTestResultType.ARHitTestResultTypeExistingPlane,
                            //ARHitTestResultType.ARHitTestResultTypeEstimatedHorizontalPlane, 
                            //ARHitTestResultType.ARHitTestResultTypeEstimatedVerticalPlane, 
                            //ARHitTestResultType.ARHitTestResultTypeFeaturePoint
                        }; 
                        
                        foreach (ARHitTestResultType resultType in resultTypes)
                        {
                            if (HitTestWithResultType (point, resultType))
                            {
                                return;
                            }
                        }
                    }
                }
            #endif

        }

    }

    void OnDestroy()
    {
        unityARAnchorManager.Destroy ();
    }

    bool HitTestWithResultType(ARPoint point, ARHitTestResultType resultTypes)
    {
        debugInfo = "";

        List<ARHitTestResult> hitResults = UnityARSessionNativeInterface.GetARSessionNativeInterface().HitTest(point, resultTypes);
        if (hitResults.Count > 0)
        {
            foreach (var hitResult in hitResults)
            {
                Debug.Log("Got hit!");
                m_HitTransform.position = UnityARMatrixOps.GetPosition(hitResult.worldTransform);
                m_HitTransform.rotation = UnityARMatrixOps.GetRotation(hitResult.worldTransform);
                Debug.Log(string.Format("x:{0:0.######} y:{1:0.######} z:{2:0.######}", m_HitTransform.position.x, m_HitTransform.position.y, m_HitTransform.position.z));
                Debug.Log("hit " + hitResult.anchorIdentifier);

                debugInfo += string.Format("x:{0:0.######} y:{1:0.######} z:{2:0.######}", m_HitTransform.position.x, m_HitTransform.position.y, m_HitTransform.position.z);
                debugInfo += "\n";
                debugInfo += hitResult.anchorIdentifier;
                debugInfo += "\n";

                planeID = hitResult.anchorIdentifier;

                return true;
            }
        }
        return false;
    }

    public void DeleteOtherPlanes()
    {
        string keysInfo = "keys are ";
        foreach (var key in unityARAnchorManager.planeAnchorMap.Keys)
        {
            keysInfo += (key + ",");
        }
        Debug.Log(keysInfo);
        if (unityARAnchorManager.planeAnchorMap.ContainsKey(planeID))
        {
            selectedPlaneAnchor = unityARAnchorManager.planeAnchorMap[planeID].planeAnchor;
            unityARAnchorManager.Destroy();
            PlaceGamePlane();
        }
        else
        {
            Debug.Log("plane ID not found");
        }

    }

    public void StopPlaneDetection()
    {
        planeDetectionStopped = true;
    }

    public void PlaceGameCharacter()
    {
        gameCharacterPlaced = true;
    }

    //public void VisualizeCenter()
    //{
    //    IEnumerable<ARPlaneAnchorGameObject> arpags = unityARAnchorManager.GetCurrentPlaneAnchors();
    //    foreach (var planeAnchorGO in arpags)
    //    {
    //        ARPlaneAnchor ap = planeAnchorGO.planeAnchor;
    //        GameObject plane = planeAnchorGO.gameObject;
    //        if (plane.transform.childCount == 1)
    //        {
    //            GameObject centerGO = GameObject.Instantiate(visPrefab);
    //            centerGO.transform.parent = planeAnchorGO.gameObject.transform;
    //            centerGO.transform.localPosition = new Vector3(ap.center.x, ap.center.y, -ap.center.z);
    //        }
    //        else
    //        {
    //            Transform childOfPlane = plane.transform.GetChild(1);
    //            childOfPlane.localPosition = new Vector3(ap.center.x, ap.center.y, -ap.center.z);
    //        }
    //    }
    //}

    public void PlaceGamePlane()
    {
        gamePlaneParent.transform.position = UnityARMatrixOps.GetPosition(selectedPlaneAnchor.transform);
        gamePlaneParent.transform.rotation = UnityARMatrixOps.GetRotation(selectedPlaneAnchor.transform);

        gamePlaneOrigin.transform.localPosition = new Vector3(selectedPlaneAnchor.center.x, selectedPlaneAnchor.center.y, -selectedPlaneAnchor.center.z);

        gamePlane.transform.localPosition = new Vector3(selectedPlaneAnchor.center.x, selectedPlaneAnchor.center.y, -selectedPlaneAnchor.center.z);
        //gamePlane.transform.localScale = new Vector3(selectedPlaneAnchor.extent.x * 0.1f, gamePlane.transform.localScale.y, selectedPlaneAnchor.extent.z * 0.1f);
        //gamePlane.SetActive(true);
        gamePlane.transform.localScale = new Vector3(selectedPlaneAnchor.extent.x, 0.005f, selectedPlaneAnchor.extent.z);


        //Mesh planeMesh = gamePlane.GetComponent<MeshFilter>().mesh;

        //Debug.Log(planeMesh.bounds.extents.ToString("F5"));

        Debug.Log(gamePlane.GetComponent<Collider>().bounds.extents.ToString("F5"));

        m_HitTransform.parent = gamePlaneOrigin.transform;

    }

    //public void DisplayHitInfo()
    //{
    //    debugTextBox.text = debugInfo;
    //}


}


